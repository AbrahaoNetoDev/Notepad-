OVERVIEW DE TUDO QUE ESTOU USANDO:


 Domain-Driven Design (DDD) - Design orientado por dom√≠nio


Quando se fala em Domain-Driven Design (DDD), logo se pensa no modelo arquitetural, nos building blocks do DDD e nos design patterns relacionados.

E √© claro que n√≥s somos apaixonados por isso, afinal somos desenvolvedores! ‚ù§Ô∏è

Por√©m, para trabalhar com DDD precisamos desenvolver mais alguns skills, como aprender a modelar dom√≠nios de forma efetiva, e, para isso, precisamos nos tornar o que o Eric Evans
 chama de Knowledge Crunchers ‚Äî processadores de conhecimento ‚Äî algu√©m preparado para receber, filtrar e organizar uma avalanche de informa√ß√£o.

Domain-Driven Design √©, antes de tudo, comunica√ß√£o. No DDD modelagem e implementa√ß√£o andam juntas.

Especialistas do dom√≠nio (usu√°rios, analistas e outros especialistas da √°rea), juntamente com os desenvolvedores e arquitetos trabalham de m√£os dadas com um objetivo em comum:
 construir software guiado pelo dom√≠nio para atender as necessidades do cliente.

Para fazer isso, em primeiro lugar, √© necess√°rio que todos usem uma linguagem em comum e que n√£o haja tradu√ß√£o na comunica√ß√£o entre os membros do time.

O time desenvolve, portanto, uma linguagem ub√≠qua (geral e universal) que expressa o conhecimento dos especialistas de neg√≥cio para o modelo de dom√≠nio (para o c√≥digo).

O dom√≠nio pode ser t√£o complexo quanto os processos e dados que ele compreende.

E O MODELO?

Um modelo √©, de acordo com Evans (2004, p. 2) ‚Äúuma simplifica√ß√£o. √â uma interpreta√ß√£o da realidade que abstrai os aspectos relevantes para resolver o problema em quest√£o e ignorar 
detalhes alheios a isto‚Äù (tradu√ß√£o livre).

COM UM MODELO CONSEGUIMOS:

Abstrair a complexidade do neg√≥cio atrav√©s de uma representa√ß√£o simplificada do mesmo ‚Äî um modelo.

O modelo serve como algo comum e palp√°vel a todos os membros do time, que, junto com a linguagem ub√≠qua, permite que todos possam participar ativamente da constru√ß√£o progressiva do
 mesmo.
 
O modelo (desde que feito corretamente) garante que aquilo que est√° sendo especificado √© o que est√° sendo implementado.

O modelo √© o meio de comunica√ß√£o usado pelo time. Gra√ßas ao v√≠nculo entre o modelo e a implementa√ß√£o, os desenvolvedores podem falar na linguagem do software ao comunicarem-se com os
 especialistas do dom√≠nio (sem ter que traduzir a mensagem).
 
O modelo √© o conhecimento destilado ‚Äî √© o modo como o time concorda em estruturar o conhecimento extra√≠do do dom√≠nio.
EVANS (2004)

O modelo √© evolutivo: A cada itera√ß√£o entre especialistas de dom√≠nio e a equipe t√©cnica, o modelo se torna mais profundo e expressivo, mais rico, e os desenvolvedores transferem essa
 fonte de valor para o software.

Assim, o modelo vai sendo gradualmente enriquecido com o expertise dos especialistas do dom√≠nio destilado pelos desenvolvedores, fazendo com que o time ganhe cada vez mais insight 
sobre o neg√≥cio e que esse conhecimento seja transferido para o modelo (para o c√≥digo) atrav√©s dos blocos de constru√ß√£o do DDD.

Quando novas regras de neg√≥cio s√£o adicionadas e/ou regras existentes s√£o alteradas ou removidas, a implementa√ß√£o √© refatorada para refletir essas altera√ß√µes do modelo no c√≥digo.

No final, o modelo (que em √∫ltima inst√¢ncia ser√° o software) vai expressar com riqueza de conhecimento o neg√≥cio.

Como explica Evans (2004, p. 23) ‚ÄúDDD coloca um monte de conhecimento no modelo que reflete profundamente o dom√≠nio.

Isso s√≥ √© poss√≠vel atrav√©s da colabora√ß√£o entre quem conhece o dom√≠nio e quem sabe criar software. ü§ù

E como o desenvolvimento √© iterativo, essa colabora√ß√£o continua durante todo o andamento do projeto.‚Äù

Ou seja, o Domain-Driven Design nos leva a construir softwares guiados pelo conhecimento e modelagem do neg√≥cio antes de qualquer apelo por tecnologia.

Obviamente para que possamos implementar o modelo de dom√≠nio com sucesso, precisamos de engenharia. üòé

E, por isso, o DDD nos conduz atrav√©s dos seus blocos de constru√ß√£o a utilizar alguns princ√≠pios de arquitetura e design patterns consagrados, entre eles destaco:

Isolamento do dom√≠nio com arquitetura em camadas.

Representa√ß√£o do modelo atrav√©s de artefatos de software bem definidos (entities, value objects, services, factories, repositories, specs, modules, etc).

Gerenciamento do ciclo de vida de objetos do dom√≠nio com aggregates.

Demonstrarei na pr√°tica cada um deles nos pr√≥ximos artigos desta s√©rie sobre Domain-Driven Design. Mas agora voltemos √† teoria, pois √© necess√°rio antes ter um bom fundamento 
se quisermos construir um modelo realmente efetivo.

OS 5 INGREDIENTES DE UM MODELO EFETIVO:

Vincular o modelo com a implementa√ß√£o: esse v√≠nculo √© feito desde o in√≠cio, quando o modelo ainda √© primitivo e ser√° mantido at√© o fim. Esse v√≠nculo √© profundo, a implementa√ß√£o
 deve= refletir 100% o modelo.
 
Cultivar uma linguagem baseada no modelo: no in√≠cio ser√° necess√°rio que os desenvolvedores e os domain experts entendam cada um os termos do outro, mas depois ambos falar√£o a 
mesma linguagem, organizando as senten√ßas da comunica√ß√£o numa estrutura consistente com o modelo e sem ambiguidades.

Desenvolver um modelo rico em conhecimento: objetos t√™m dados e comportamentos associados. O modelo n√£o deve ser apenas uma estrutura de dados (modelo an√™mico), ele deve capturar o 
conhecimento do dom√≠nio para resolver os problemas do dom√≠nio.

Destilar o modelo: o modelo deve ser refinado. Assim como conceitos importantes devem ser adicionados, conceitos que n√£o tem relev√¢ncia devem ser removidos. A cada itera√ß√£o o modelo
 ficar√° mais rico e ter√° mais valor.
 
Brainstorming e experimenta√ß√£o: a intera√ß√£o direta entre os desenvolvedores e domain experts, atrav√©s de brainstormings e diagramas feitos na hora, transformam as discuss√µes em 
laborat√≥rios do modelo, no qual diversas varia√ß√µes de experimentos podem ser exercitadas e o resultado pode ser usado se mostrar valor ou descartado caso contr√°rio.
EVANS (2004).






O QUE √â O ENTITY FRAMEWORK CORE? 



Entity Framework Core (EF Core) √© a vers√£o mais recente do Entity Framework da Microsoft. Ele foi projetado para ser leve, extens√≠vel e para oferecer suporte ao desenvolvimento
 de plataforma cruzada como parte da estrutura .NET Core da Microsoft.
 Ele tamb√©m foi projetado para ser mais simples de usar e oferecer melhorias de desempenho em rela√ß√£o √†s vers√µes anteriores do Entity Framework.

O EF Core √© um mapeador relacional de objeto (ORM). O mapeamento objeto-relacional √© uma t√©cnica que permite aos desenvolvedores trabalhar com dados de maneira orientada a objetos, 
realizando o trabalho necess√°rio para mapear entre objetos definidos na linguagem de programa√ß√£o de um aplicativo e dados armazenados em fontes de dados relacionais .

Por que usar um ORM? 


A maioria das estruturas de desenvolvimento inclui bibliotecas que permitem o acesso a dados de bancos de dados relacionais por meio de estruturas de dados semelhantes a conjuntos
 de registros. O exemplo de c√≥digo a seguir ilustra um cen√°rio t√≠pico em que os dados s√£o recuperados de um banco de dados e armazenados em um ADO.NET DataTablepara que possam ser 
 acessados ‚Äã‚Äãpelo c√≥digo do programa:

using(var conn = new SqlConnection(connectionString))
using(var cmd = new SqlCommand("select * from Products", conn))
{
    var dt = new DataTable();
    using(var da = new SqlDataAdapter(cmd))
    {
        da.Fill(dt);
    }
}
Os dados dentro do DataTable s√£o acess√≠veis por meio de indexadores num√©ricos ou de string e precisam ser convertidos objectpara o tipo correto:

foreach(DataRow row in dt.Rows)
{
    int productId = Convert.ToInt32(row[0]);
    string productName = row["ProductName"].ToString();
}
Essa abordagem de limite tardio ou "tipagem fraca" para acesso a dados √© propensa a erros. Os problemas geralmente surgem da digita√ß√£o incorreta do nome de uma coluna ou da 
descoberta de que o nome da coluna foi alterado no banco de dados ou de uma altera√ß√£o na ordem na qual os campos s√£o especificados na instru√ß√£o SQL sem que uma altera√ß√£o 
correspondente seja feita no c√≥digo do aplicativo. Da mesma forma, as convers√µes de tipo de dados podem falhar. O c√≥digo ainda ser√° compilado, mas ocorrer√° um erro em tempo
 de execu√ß√£o. Consequentemente, os desenvolvedores profissionais preferem trabalhar com dados de maneira fortemente tipada.

Digita√ß√£o forte 
Ao adotar uma abordagem fortemente tipada aos dados, voc√™ trabalha com propriedades de classes predefinidas que formam um modelo de dom√≠nio de forma orientada a objetos:

public class Product
{
    int ProductId { get; set; }
    string ProductName { get; set; }
}
int productId = myProduct.ProductId;
string productName = myProduct.ProductName;
O trabalho ainda precisa ser feito para recuperar e mapear os dados do banco de dados para uma inst√¢ncia do objeto de dom√≠nio. Uma op√ß√£o √© escrever seu pr√≥prio c√≥digo para 
gerenciar isso. No entanto, √† medida que o modelo de dom√≠nio cresce, a quantidade de c√≥digo necess√°ria pode crescer e precisar√° de mais e mais tempo de desenvolvimento para 
manter. Isso aumentar√° o tempo total necess√°rio para concluir uma inscri√ß√£o.

ORMs s√£o bibliotecas de c√≥digo pr√©-escritas que fazem esse trabalho para voc√™. Os ORMs completos tamb√©m fazem muito mais. Eles podem
mapear um modelo de dom√≠nio para objetos de banco de dados
criar bancos de dados e manter o esquema alinhado com as altera√ß√µes no modelo
gerar SQL e execut√°-lo no banco de dados
gerenciar transa√ß√µes
manter o controle de objetos que j√° foram recuperados




ORM OBJECT RELATIONAL MAPPER - MAPEADOR RELACIONAL DE OBJETOS


 (Object Relational Mapper) √© uma t√©cnica de mapeamento objeto relacional que permite fazer uma rela√ß√£o dos objetos com os dados que os mesmos representam. Ultimamente
 tem sido muito utilizada e vem crescendo bastante nos √∫ltimos anos.

Este crescimento tem se dado principalmente pelo fato de muitos desenvolvedores n√£o se sentirem a vontade em escrever c√≥digo SQL e pela produtividade que esta t√©cnica nos 
proporciona. Existem √≥timos ORM¬¥s como Hibernate, NHibernate, Entity Framework e etc.


No mundo relacional prevalecem princ√≠pios matem√°ticos com a finalidade de armazenar e gerenciar corretamente os dados, de forma segura e se trabalha com a linguagem SQL que 
√© utilizada para dizer o banco de dados ‚ÄúO QUE?‚Äù fazer e n√£o como fazer.

J√° no mundo orientado a objetos trabalhamos com classes e m√©todos, ou seja, trabalhamos fundamentados na engenharia de software e seus princ√≠pios que nos dizem ‚ÄúCOMO‚Äù fazer. 
O ORM √© justamente, a ponte entre estes dois mundos, ou seja, √© ele quem vai permitir que voc√™ armazene os seus objetos no banco de dados.

Para isto precisamos fazer um mapeamento dos seus objetos para as tabelas do banco de dados.

banco de dados e cada ORM tem suas particularidades para gerar o SQL referente a inser√ß√£o do objeto que corresponde a uma tabela no banco de dados e realizar a opera√ß√£o. 
Utilizando um ORM, tamb√©m se ganha produtividade, pois deixa-se de escrever os comando SQL para deixar que o pr√≥prio ORM, 
fa√ßa isto por voc√™.





SQL STANDARD QUERY LANGUAGE - LINGUAGEM DE CONSULTA PADR√ÉO:

SQL √© uma linguagem padr√£o para trabalhar com bancos de dados relacionais. Ela √© uma linguagem declarativa e que n√£o necessita de profundos conhecimentos de programa√ß√£o para que 
algu√©m possa come√ßar a escrever queries, as consultas e pedidps, que trazem resultados de acordo com o que voc√™ est√° buscando. SQL significa Standard Query Language, literalmente
 a linguagem padr√£o para realizar queries.

A linguagem SQL √© utilizada de maneira relativamente parecida entre os principais bancos de dados relacionais do mercado: Oracle, MySQL, MariaDB, PostgreSQL, Microsoft SQL Server,
 entre muitos outros. Cada um tem suas caracter√≠sticas, sendo o MySQL e o PostgreSQL extremamente populares por possu√≠rem vers√µes gratuitas e de c√≥digo aberto.

√â tamb√©m uma linguagem que muitos profissionais acabam precisando aprender: seja quem usa Excel de forma pesada e acaba migrando as informa√ß√µes para um banco de dados, seja um 
cientista de dados que usa Python para agregar os dados das diferentes fontes de informa√ß√µes.

Quais s√£o os principais comandos SQL?
Os principais comandos SQL s√£o:

SELECT: busca linhas em tabelas de acordo com um crit√©rio definido dentro da chamada cl√°usula de WHERE

INSERT: insere novas linhas na tabela. no nosso caso, colocaria novas notas fiscais dado os argumentos que s√£o passados para o INSERT. Por exemplo, no nosso caso: INSERT INTO nf 
(titulo, pagamento, valor) VALUES 'canetas',
 '2019-07-15', 150.
 
UPDATE: atualiza linhas do banco de dados de acordo com um crit√©rio de WHERE, como mudar o CPF

DELETE: remove linhas da tabela de acordo com um crit√©rio.

H√° ainda uma infinidade de subcomandos para fazer buscas melhores e mais elaboradas, como JOIN, LIKE, HAVING e GROUP BY.

N√£o se assuste! O trabalho b√°sico com tabelas, linhas, colunas, relacionamentos e chaves n√£o demanda um conhecimento extenso de SQL. Ele vai se fazer necess√°rio para otimizar 
consultas e tomar decis√µes de como modelar esses dados.

DQL - Linguagem de Consulta de Dados - Define o comando utilizado para que possamos consultar (SELECT) os dados armazenados no banco;

DML - Linguagem de Manipula√ß√£o de Dados - Define os comandos utilizados para manipula√ß√£o de dados no banco (INSERT, UPDATE e DELETE);

DDL - Linguagem de Defini√ß√£o de Dados - Define os comandos utilizados para cria√ß√£o (CREATE) de tabelas, views, √≠ndices, atualiza√ß√£o dessas estruturas (ALTER), assim como a 
remo√ß√£o (DROP);

DCL - Linguagem de Controle de Dados - Define os comandos utilizados para controlar o acesso aos dados do banco, adicionando (GRANT) e removendo (REVOKE) permiss√µes de acesso;

DTL - Linguagem de Transa√ß√£o de Dados - Define os comandos utilizados para gerenciar as transa√ß√µes executadas no banco de dados, como iniciar (BEGIN) uma transa√ß√£o, 
confirm√°-la (COMMIT) ou desfaz√™-la (ROLLBACK).




SQL DQL - DATA QUERY LANGUAGE - LINGUAGEM DE CONSULTA DE DADOS


Como voc√™ j√° pode notar e verificar√° ao longo da sua carreira, uma das tarefas mais corriqueiras em bancos de dados √© a execu√ß√£o de queries. Portanto, saber cri√°-las da melhor 
maneira √© muito importante para 
o desempenho do banco e de aplica√ß√µes que dele dependam.

Neste momento, de primeiros passos, voc√™ n√£o precisa se preocupar tanto com isso, mas recomendamos que pense sobre esse assunto a cada novo recurso relacionado a consultas que estudar.

O curso abaixo lhe ensinar√° a criar consultas em SQL, a utilizar o comando SELECT. Conheceremos, assim, alguns dos principais recursos, por exemplo: ordena√ß√£o de registros, fun√ß√µes de
 agrega√ß√£o, jun√ß√µes, entre outros.
 
 SQL DML - Data Manipulation Language
Para a manipula√ß√£o de dados no banco, temos como comandos da linguagem SQL o INSERT, UPDATE e DELETE, os quais inserem, atualizam e removem dados, respectivamente.





O QUE √â O ANGULAR?


√â um framework JavaScript de c√≥digo aberto mantido pela Google para a constru√ß√£o de SPA (sigla para Single Page Applications ou Aplica√ß√µes de P√°gina √önica). Resumidamente, uma SPA √©
 basicamente uma aplica√ß√£o web constru√≠da em uma s√≥ p√°gina, na qual a intera√ß√£o e a navega√ß√£o entre as sess√µes de uma p√°gina ocorrem de maneira a qual n√£o √© necess√°rio recarregar a
 p√°gina em cada uma dessas mudan√ßas.

Sua finalidade √© nos dar ferramentas necess√°rias para cria√ß√£o de aplica√ß√µes SPA, al√©m disso tamb√©m deixa o desenvolvimento deste tipo de aplica√ß√£o mais simples e otimizado. Com ele,
 podemos desenvolver aplica√ß√µes web voltadas tanto para resolu√ß√µes desktop quanto para resolu√ß√µes mobile, tornando-as din√¢micas, modernas e escal√°veis.

Com o Angular, temos um novo paradigma de desenvolvimento focado nos dados da aplica√ß√£o. Ele n√£o utiliza uma virtualiza√ß√£o do DOM para manipul√°-lo: ele utiliza mecanismos pr√≥prios de
 detec√ß√£o de altera√ß√µes na interface, altera√ß√µes tas disparadas principalmente por uma estrutura chamada Two-Way Data Binding.

O Two-Way Data Binding mant√©m o model e a view sempre atualizados entre si, ou seja: sempre que algum model √© atualizado, essa altera√ß√£o se reflete automaticamente na view.

AngularJS ou somente Angular?
Provavelmente, voc√™ j√° ouviu falar de Angular e AngularJS e pode ter ficado em d√∫vida se √© a mesma tecnologia, porque que uma tem ‚ÄúJS‚Äù no nome e a outra n√£o. A resposta √©: embora o
 Angular seja a evolu√ß√£o ap√≥s o AngularJS, eles praticamente s√£o frameworks diferentes.

O AngularJS come√ßou em 2009, sendo definido pelas vers√µes 1.x. J√° o Angular (antes conhecido como ‚ÄúAngular 2‚Äù, publicado em 2016) √© considerado a vers√£o 2 mais as vers√µes superiores.
 Muitos pensam que o Angular √© uma continua√ß√£o do AngularJS em termos de c√≥digo, o que n√£o √© verdade.

A vers√£o 2, chamada hoje somente de Angular, foi uma reescrita completa do c√≥digo e tornou-se uma arquitetura completamente diferente, mantendo apenas o nome ‚Äì por√©m sem o JS no final.
 Nesta nova ferramenta, foram seguidos padr√µes da web moderna, t√©cnicas e boas pr√°ticas que foram aprendidas com os erros cometidos no desenvolvimento da ferramenta anterior.

O AngularJS tinha como linguagem padr√£o o JavaScript. J√° o Angular ainda continua baseado no JavaScript, mas atrav√©s do TypeScript. Com isso, ele passou a oferecer capacidades 
interessantes antes oferecidas somente pelo TypeScript.

Caracter√≠sticas
Suas principais caracter√≠sticas s√£o:

‚Ä¢ Suporte cross-platform: esse framework fornece suporte a m√∫ltiplas plataformas de desenvolvimento. O Angular pode ser utilizado para criar aplica√ß√µes web SPA, aplica√ß√µes mobile 
(com o suporte do Ionic, por exemplo) ou at√© mesmo aplica√ß√µes desktop (com o suporte do Electron).

Mesmo em ambientes distintos, a API do Angular permanece praticamente a mesma, o que facilita a curvatura de ado√ß√£o e aprendizagem em m√∫ltiplos ambientes de desenvolvimento;

‚Ä¢ Integra√ß√£o e suporte √† todas as fases de desenvolvimento: prov√™ ferramental e suporte para todas as fases de desenvolvimento, desde a escrita do c√≥digo em si (apoiando-se bastante 
na API e no sistema de tipos do TypeScript) at√© a cria√ß√£o de fluxos de teste (com o apoio principalmente do Karma ‚Äì uma biblioteca para escrita de testes JavaScript), passando pelo
 suporte excelente √† cria√ß√£o de anima√ß√µes, o provisionamento de estruturas de acessibilidade e at√© mesmo o scaffolding de projetos atrav√©s do Angular CLI;

‚Ä¢ Produtividade aliada √† performance: consegue oferecer suporte ao desenvolvimento r√°pido de aplica√ß√µes atrav√©s de uma API simples, bem estruturada e bem documentada, o que acaba 
trazendo bastante produtividade.

Por fim, por mais que o Angular n√£o utilize o conceito de Virtual DOM (conceito utilizado por outros frameworks, como o React), ainda sim o Angular oferece uma performance bem 
interessante, principalmente com a Ivy, a engine de renderiza√ß√£o utilizada desde o Angular 6+.

Mercado
Atualmente o Angular √© um dos frameworks Javascript que dominam o mercado, sendo muito popular nos √∫ltimos anos e √© utilizado em in√∫meros projetos. Por esses motivos, ele vem sendo 
amplamente requisitado no mercado para desenvolvimento web e mobile, tendo diversas oportunidades no Brasil e no mundo.


